#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Jul 13 16:16:12 2022

@author: asharma
"""
import os
import sys
import time
import numpy as np
from ase import Atoms
from ase import io
from ase.geometry.analysis import Analysis
from lammps import lammps;
import math
import linecache

from sklearn.linear_model import Ridge
#from sklearn.linear_model import RidgeCV
from sklearn.metrics import mean_squared_error
from sklearn.metrics import r2_score

import scipy.optimize as optimize

import matplotlib.pyplot as plt
plt.rcParams['font.size'] = 20
plt.rcParams['axes.linewidth'] = 3
plt.rcParams['font.weight'] = 'bold'# 'normal' #'bold'
#plt.rcParams['axes.labelweight']='bold'
plt.rcParams['axes.labelsize']=25
plt.rcParams['legend.fontsize']=20

#sys.path.append(os.getcwd())
#from aSNAP_v36 import *

import dam.aSNAP as AS
#-----------------------------------------------------------------------------
#This library has many functions to
#1. Convert files of different format
#2. Clean/reorder/align trajectories


#******************************************************************************
#This section have functions to convert files of different format to each other
#------------------------------------------------------------------------------
def poscar2axyz(fposcar,fxyz):
    #fposcar: Input poscar file (generated by VESTA)
    #fxyz:  Output file in axyz format
    #**Works with only one configuration
    f = open(fposcar,'r')
    for i in range(2):f.readline()
    A = np.asarray(f.readline().split()[0:3], dtype = float)
    B = np.asarray(f.readline().split()[0:3], dtype = float)
    C = np.asarray(f.readline().split()[0:3], dtype = float)
    elist = f.readline().split()
    efreq = [int(i) for i in f.readline().split()]        
    coord_type=f.readline().split()
    print(A,B,C,efreq,coord_type)
    
    fx = open(fxyz,'w')
    fx.write(f'{sum(efreq)} \nsnap energy {A[0]} {A[1]} {A[2]} {B[0]} {B[1]} {B[2]} {C[0]} {C[1]} {C[2]} \n')
    if(coord_type[0][0] == 'C'):
        print('Writing xyz file from given cartesian coordinates in poscar')
        for at in range(len(efreq)):
            for atn in range(efreq[at]):
                l = f.readline().split()
                fx.write(f'{elist[at]} {l[0]} {l[1]} {l[2]}\n')
    else:
        print('Given coordinates in POSCAR are not cartesian, recheck or write code to convert fractional to cartesian')    
    f.close()
    fx.close()
#

def axyz2poscar(fxyz,fposcar):
    #fxyz:  Input file in axyz format
    #fname: Output poscar file (generated by VESTA)
    #**Works with only one configuration
    f = open(fxyz,'r')
    Na = int(f.readline())
    l = f.readline().split()
    
    fp = open(fposcar,'w')
    fp.write('Material\n1.0\n')
    fp.write(f'    {l[2]} {l[3]} {l[4]}\n    {l[5]} {l[6]} {l[7]}\n    {l[8]} {l[9]} {l[10]}\n')
    
    e=[]
    C=np.zeros([Na,3],dtype=float)
    for i in range(Na):
        l=f.readline().split()
        e.append(l[0])
        C[i]=l[1:4]
    f.close()
    
    e_unique = set(e);
    e_unique_freq = [e.count(i) for i in e_unique]
    
    for i in e_unique:fp.write(f'    {i}')
    fp.write('\n')
    for i in e_unique_freq:fp.write(f'    {i}')
    fp.write('\nCartesian\n')
    
    for i in e_unique:
        for j in range(Na):
            if(i ==e[j]):
                fp.write(f'    {C[j][0]}    {C[j][1]}    {C[j][2]}\n')
    fp.close()
#

def axyz2lmpdata(faxyz,frno,fdata,ele,masses,tp): # Replace it to create lammps object directly with atoms, to avoid file creation
    #faxyz: Name of xyz file
    #fdata: Name of data file
    #frno:  Frame number of xyz file to write as data file; starts from zero
    #ele: List of elements in proper order
    #masses: List of masses in proper order
    #tp: el or at (el: as per element, at: as per atomtype)
    Na = int(linecache.getline(faxyz,1).split()[0])
    lno = frno*(Na+2)+1
    l2=linecache.getline(faxyz,lno+1).split();
    A=np.array(l2[2:5],dtype=float)
    B=np.array(l2[5:8],dtype=float)
    C=np.array(l2[8:11],dtype=float)
    atm_tp=[];
    coord=np.zeros([Na,3],dtype=float);#>>Atomic coordinates
    for i in range(Na):
        l=linecache.getline(faxyz,lno+2+i).split();
        if(tp=='at'):
            atm_tp.append(ele.index((l[0]))+1);
        else:
            if(l[0][1] in '0123456789'):el = atm_tp.append(ele.index((l[0][0]))+1) 
            if(l[0][2] in '0123456789'):el = atm_tp.append(ele.index((l[0][0:2]))+1) 
        coord[i]=l[1:4];

    os.system('rm '+fdata)
    fd=open(fdata,'w');
    fd.write('LAMMPS data file\n\n');
    fd.write(f"{Na} atoms\n0 bonds\n0 angles\n0 dihedrals\n0 impropers\n\n{len(masses)} atom types\n0 bond types\n0 angle types\n0 dihedral types\n0 improper types\n\n");
    #lx = A[0];
    #xy = B[0];ly = B[1];
    #xz = C[0];yz = C[1];lz = C[2];
    fd.write('   0.0 '+str(A[0])+' xlo xhi \n');### Change here to control box dimension
    fd.write('   0.0 '+str(B[1])+' ylo yhi \n');
    fd.write('   0.0 '+str(C[2])+' zlo zhi \n');
    fd.write('   '+str(B[0])+' '+str(C[0])+' '+str(C[1])+' xy xz yz \n');### Change here to control box tilt round(xy,3)
    fd.write('\nMasses\n\n')
    for i in range(len(masses)):fd.write(f"{i+1} {masses[i]}\n");
    fd.write('\nAtoms\n\n')
    for i in range(Na):
        cw=str(0.0)+'\t'+str(coord[i][0])+'\t'+str(coord[i][1])+'\t'+str(coord[i][2]);
        fd.write(str(i+1)+'\t1\t'+str(atm_tp[i])+'\t'+cw+'\t0\t0\t0\n');
    fd.close();
#


#------------------------------------------------------------------------------
#******************************************************************************


#******************************************************************************
#This section have functions to clean/sort trajectories
#------------------------------------------------------------------------------
def axyz2vmdbox(fin_axyz):
    fi = open(fin_axyz,'r')
    fo = open('cell.tcl','w')
    Nconfig = int(os.popen('cat '+fin_axyz+' | grep snap | wc -l').read())

    for i in range(Nconfig):
        Na = int(fi.readline().split()[0])
        val=fi.readline().split()
        A=np.asarray([val[2], val[3], val[4]], dtype = np.float64)
        B=np.asarray([val[5], val[6], val[7]], dtype = np.float64)
        C=np.asarray([val[8], val[9], val[10]], dtype = np.float64)
        cc = AS.Cell()
        a,b,c,alpha,beta,gamma = cc.vec2para(A,B,C)
        fo.write('animate goto '+str(i)+'\n pbc set {'+str(a)+' '+str(b)+' '+str(c)+' '+str(alpha*180/math.pi)+' '+str(beta*180/math.pi)+' '+str(gamma*180/math.pi)+'}\n')
        for j in range(Na):fi.readline()
    fo.close()
    fi.close()
#

def remove_at_axyz(fin_axyz,fout_axyz):
    #To remove atom types from axyz file if its there
    Nconfig = int(os.popen('cat '+fin_axyz+' | grep snap | wc -l').read())

    fi = open(fin_axyz,'r')
    fo = open(fout_axyz,'w')
    for i in range(Nconfig):
        Na = int(fi.readline().split()[0])
        fo.write(f'{Na}\n')
        fo.write(fi.readline())#Writing second line
        for j in range(Na):
            l=fi.readline().split()
            el = l[0];
            if(l[0][1] in '0123456789'):el = l[0][0]
            elif(l[0][2] in '0123456789'):el = l[0][0:2] ##Note: Earlier it was just if
            st = el
            for i in range(len(l)-1):st = st+' '+l[i+1]
            fo.write(st+'\n')
#

def add_at_axyz(fin_axyz,fout_axyz,atm_tp):
    #To add atom types in axyz file 
    Nconfig = int(os.popen('cat '+fin_axyz+' | grep snap | wc -l').read())
    fi = open(fin_axyz,'r')
    fo = open(fout_axyz,'w')
    for i in range(Nconfig):
        Na = int(fi.readline().split()[0])
        fo.write(f'{Na}\n')
        fo.write(fi.readline())#Writing second line
        for j in range(Na):
            l=fi.readline().split()
            st = atm_tp[j]
            for i in range(len(l)-1):st = st+' '+l[i+1]
            fo.write(st+'\n')
#
def xyz2esortxyz(fin,fsort,keyword,elist):
    #This function will arrange the rows xyz files according to the elements (not atom types)
    #fname: name of input xyz file
    #fsort: name of output file where element wise sorted xyz file will be written
    #keyword: this string will be use to find number of snapshots in the file
    #elist: list of elements order. the output file will be written based on this order
    
    fi   = open(fin,'r')
    fsort = open(fsort,'w')
    
    Nconfig = int(os.popen('cat '+fin+' | grep '+ keyword + ' | wc -l').read())
    print('Going to sort ',Nconfig,' configurations')
    
    for i in range(Nconfig):
        Na = int(fi.readline().split()[0])
        fsort.write(f'{Na}\n')
        fsort.write(fi.readline())#Writing second line
        
        C  = []
        for j in range(Na):
            C.append(fi.readline())
            
        
        for j in elist:
            for k in range(Na):
                if(j==C[k].split()[0]):fsort.write(C[k])
    fi.close();
    fsort.close();
#
def addzeroq_xyz(fin,fout,keyword):
    #This function will add zero charges in the end of atomic data (e.g. C x y z fx fy fz -> C x y z fx fy fz 0.0
    #fname: name of input xyz file
    #fout: name of output file
    #keyword: this string will be use to find number of snapshots in the file
    fi = open(fin,'r')
    fo = open(fout,'w')
    
    Nconfig = int(os.popen('cat '+fin+' | grep '+ keyword + ' | wc -l').read())
    print('Going to sort ',Nconfig,' configurations')
    
    for i in range(Nconfig):
        Na = int(fi.readline().split()[0])
        fo.write(f'{Na}\n')
        fo.write(fi.readline())#Writing second line
        for j in range(Na):
            ll = fi.readline().split()
            fo.write(f'{ll[0]} {ll[1]} {ll[2]} {ll[3]} {ll[4]} {ll[5]} {ll[6]} 0.0\n')
    fi.close();
    fo.close();
#
def removeq_xyz(fin,fout,keyword):
    #This function will remove charges in the end of atomic data (e.g. C x y z fx fy fz -> C x y z fx fy fz 
    #fname: name of input xyz file
    #fout: name of output file
    #keyword: this string will be use to find number of snapshots in the file
    fi = open(fin,'r')
    fo = open(fout,'w')
    
    Nconfig = int(os.popen('cat '+fin+' | grep '+ keyword + ' | wc -l').read())
    print('Going to remove charges frome ',Nconfig,' configurations')
    
    for i in range(Nconfig):
        Na = int(fi.readline().split()[0])
        fo.write(f'{Na}\n')
        fo.write(fi.readline())#Writing second line
        for j in range(Na):
            ll = fi.readline().split()
            fo.write(f'{ll[0]} {ll[1]} {ll[2]} {ll[3]} {ll[4]} {ll[5]} {ll[6]} \n')
    fi.close();
    fo.close();
#

def axyz2_jlxyz(fin,fout,keyword):
    #This function convert file in axyz format to jl compatible extended xyz
    #fname: name of input xyz file
    #fout: name of output file
    #keyword: this string will be use to find number of snapshots in the file
    fi = open(fin,'r')
    fo = open(fout,'w')
    
    Nconfig = int(os.popen('cat '+fin+' | grep '+ keyword + ' | wc -l').read())
    print('Going to remove charges frome ',Nconfig,' configurations')
    
    for i in range(Nconfig):
        Na = int(fi.readline().split()[0])
        fo.write(f'{Na}\n')
        ll=fi.readline().split()
        
        stc=ll[2]+' '+ll[3]+' '+ll[4]+' '+ll[5]+' '+ll[6]+' '+ll[7]+' '+ll[8]+' '+ll[9]+' '+ll[10];
        sts=ll[11]+' '+ll[16]+' '+ll[15]+' '+ll[16]+' '+ll[12]+' '+ll[14]+' '+ll[15]+' '+ll[14]+' '+ll[13];
        
        e=[]
        coord=[];   
        stf='';   
        for j in range(Na):
            l = fi.readline().split()
            el = l[0];
            if(l[0][1] in '0123456789'):el = l[0][0]
            if(l[0][2] in '0123456789'):el = l[0][0:2]
            e.append(el)
            coord.append([float(l[1]),float(l[2]),float(l[3])])
            stf += '['+l[4]+', '+l[5]+', '+l[6]+'], '
        stf=stf[:-2]#Removing last two characters
        fo.write('Lattice="'+stc+'" Properties=species:S:1:pos:R:3 energy='+ll[1]+' forces="_JSON ['+stf+']" stress="'+sts+'" index='+str(i+1)+' pbc="T T T"\n')#Writing second line
        for j in range(Na):
            fo.write(f'{e[j]} {coord[j][0]} {coord[j][1]} {coord[j][2]}  \n')
    fi.close();
    fo.close();
#
def align_cellnData(in_fname, out_fname,toalign):
    #***This will work on files in axyz format 
    #Purpose: To align cell vectors, atomic coordinates, forces, and stress are aligned***
    #in_fname
    #out_fname
    #toalign: 'CFS'/'C'/..., Coordinate, Forcess, Stress
    in_file  = open(in_fname,'r')
    out_file = open(out_fname,'w')
    
    Nconfigs=int(os.popen('cat '+in_fname+' | grep snap | wc -l').read().strip())
    for i in range(Nconfigs):
        Na= int(in_file.readline().split()[0])
        val = in_file.readline().split()
        #print(val,'--',val[0],Na)
    
        A=np.asarray([val[2], val[3], val[4]], dtype = np.float64)
        B=np.asarray([val[5], val[6], val[7] ], dtype = np.float64)
        C=np.asarray([val[8], val[9], val[10] ], dtype = np.float64)
        if('S' in toalign):stress=np.asarray([[val[11], val[16], val[15]], [val[16], val[12], val[14]], [val[15], val[14] , val[13]]],dtype = float)
    
        a=np.sqrt(A.dot(A));
        b=np.sqrt(B.dot(B));
        c=np.sqrt(C.dot(C));
        alpha=math.acos(B.dot(C)/b/c);
        beta=math.acos(A.dot(C)/a/c);
        gamma=math.acos(B.dot(A)/a/b);
    
        F2C=np.asarray([A,B,C]).T
        C2F=np.linalg.inv(F2C)
    
        An=np.asarray([a ,0.,0.])
        bx = b*math.cos(gamma)
        by = b*math.sin(gamma)
        Bn = np.asarray([bx ,by,0.])
        cx = c*math.cos(beta)
        cy = (np.dot(B,C)-bx*cx)/by
    
        Cn=np.asarray([cx, cy, math.sqrt(c*c - cx*cx -cy*cy)])
        F2Cn = np.asarray([An,Bn,Cn]).T
        T = np.matmul(F2Cn,C2F)

        if('S' in toalign):
            stressn = np.matmul(T,np.matmul(stress,T.T))
            out_file.write(f'{Na}\n{val[0]} {val[1]} {An[0]} {An[1]} {An[2]} {Bn[0]} {Bn[1]} {Bn[2]} {Cn[0]} {Cn[1]} {Cn[2]} {stressn[0][0]} {stressn[1][1]} {stressn[2][2]} {stressn[1][2]} {stressn[0][2]} {stressn[0][1]}\n')
        else:
            out_file.write(f'{Na}\n{val[0]} {val[1]} {An[0]} {An[1]} {An[2]} {Bn[0]} {Bn[1]} {Bn[2]} {Cn[0]} {Cn[1]} {Cn[2]} \n')
    
        for i in range(Na):
            l1 = in_file.readline().split()
            C = np.asarray(l1[1:4],dtype=np.float64)
            Cn = T.dot(C.T)
            if('F' in toalign):
                F = np.asarray(l1[4:7],dtype=np.float64)
                Fn = T.dot(F.T)
                out_file.write(f'{l1[0]} {Cn[0]} {Cn[1]} {Cn[2]} {Fn[0]} {Fn[1]} {Fn[2]} {l1[7]}\n')
            else:
                out_file.write(f'{l1[0]} {Cn[0]} {Cn[1]} {Cn[2]} \n')
#

def lammptraj2axyz(flmp,faxyz,fcst,lcst,element_list):
    #flmp
    #faxyz
    #fcst: fist configuration step
    #lcst: last configuration step
    f  = open(flmp,'r')
    fa = open(faxyz,'w')
    for i in range(fcst):#Ignoring initial frames
        for j in range(3):f.readline()
        Na=int(f.readline().split()[0]);
        for j in range(Na+5):f.readline();

    for i in range(fcst,lcst+1):
        for j in range(3):f.readline();#Ignoring lines
        Na=int(f.readline().split()[0]);
        #Na=int(f.readline());
        f.readline();#Ignoring line
        l=f.readline().split();
        xlob=float(l[0]);xhib=float(l[1]);xy=float(l[2]);
        l=f.readline().split();
        ylob=float(l[0]);yhib=float(l[1]);xz=float(l[2]);
        l=f.readline().split();
        zlob=float(l[0]);zhib=float(l[1]);yz=float(l[2]);
        f.readline();#Ignoring line

        xlo = xlob - min([0.0,xy,xz,xy+xz])
        xhi = xhib - max([0.0,xy,xz,xy+xz])
        ylo = ylob - min([0.0, yz])
        yhi = yhib + max([0.0, yz])
        zlo = zlob
        zhi = zhib

        A=np.array([xhi-xlo,0,0]);
        B=np.array([xy,yhi-ylo,0]);
        C=np.array([xz,yz,zhi-zlo]);
        fa.write(f'{Na}\nsnap energy {A[0]} {A[1]} {A[2]} {B[0]} {B[1]} {B[2]} {C[0]} {C[1]} {C[2]} \n')
        for j in range(Na):
            l=f.readline().split();
            r = A*float(l[2]) +B*float(l[3]) + C*float(l[4]) 
            fa.write(f'{element_list[int(l[1])-1]} {r[0]} {r[1]} {r[2]}\n')
            #The following was is being used in ovito, so don't get confused again
            #fa.write(f'{element_list[int(l[1])-1]} {float(l[2])-xlo} {float(l[3])-ylo} {float(l[4])-zlo}\n')
            #Above line does not work, as there is no change in coordinates in lammps
            #fa.write(f'{element_list[int(l[1])-1]} {float(l[2])} {float(l[3])} {float(l[4])}\n')

    fa.close()
    f.close();
#

def lammptraj2axyz_wgap(flmp,faxyz,fcst,lcst,gap,element_list):
    #flmp: Lammps trajectory file with scaled coordinates
    #faxyz
    #fcst: fist configuration step
    #lcst: last configuration step
    #gap: Ignore these many configurations
    f  = open(flmp,'r')
    fa = open(faxyz,'w')
    for i in range(fcst):#Ignoring initial frames
        for j in range(3):f.readline()
        Na=int(f.readline().split()[0]);
        for j in range(Na+5):f.readline();

    for i in range(fcst,lcst+1,gap):
        for j in range(3):f.readline();#Ignoring lines
        Na=int(f.readline().split()[0]);
        #Na=int(f.readline());
        f.readline();#Ignoring line
        l=f.readline().split();
        xlob=float(l[0]);xhib=float(l[1]);xy=0.0;
        if(len(l)>2):xy=float(l[2]);
        
        l=f.readline().split();
        ylob=float(l[0]);yhib=float(l[1]);xz=0.0;
        if(len(l)>2):xz=float(l[2]);
        
        l=f.readline().split();
        zlob=float(l[0]);zhib=float(l[1]);yz=0.0
        if(len(l)>2):yz=float(l[2]);
        f.readline();#Ignoring line

        xlo = xlob - min([0.0,xy,xz,xy+xz])
        xhi = xhib - max([0.0,xy,xz,xy+xz])
        ylo = ylob - min([0.0, yz])
        yhi = yhib + max([0.0, yz])
        zlo = zlob
        zhi = zhib

        A=np.array([xhi-xlo,0,0]);
        B=np.array([xy,yhi-ylo,0]);
        C=np.array([xz,yz,zhi-zlo]);
        fa.write(f'{Na}\nsnap energy {A[0]} {A[1]} {A[2]} {B[0]} {B[1]} {B[2]} {C[0]} {C[1]} {C[2]} \n')
        for j in range(Na):
            l=f.readline().split(); # Reading scaled (fractional) coordinates
            r = A*float(l[2]) +B*float(l[3]) + C*float(l[4])
            fa.write(f'{element_list[int(l[1])-1]} {r[0]} {r[1]} {r[2]}\n')
        #Ignoring frames in between
        for i in range(gap):
            for j in range(3):f.readline()
            Na=int(f.readline().split()[0]);
            for j in range(Na+5):f.readline();

    fa.close()
    f.close();
#

#------------------------------------------------------------------------------
#******************************************************************************

def repeataxyz(fin_axyz,fout_axyz,ra,rb,rc):
    f  = open(fin_axyz,'r')
    fo = open(fout_axyz,'w');
    Na = int(f.readline())
    l  = f.readline().split()
    A  = np.array([float(l[2]),float(l[3]),float(l[4])]) 
    B  = np.array([float(l[5]),float(l[6]),float(l[7])])
    C  = np.array([float(l[8]),float(l[9]),float(l[10])])
    F2C=np.asarray([A,B,C]).T
    C2F=np.linalg.inv(F2C)

    fo.write(f'{ra*rb*rc*Na}\n {l[0]} {l[1]} {ra*A[0]}  {ra*A[1]}  {ra*A[2]}  {rb*B[0]}  {rb*B[1]}  {rb*B[2]} {rc*C[0]}  {rc*C[1]}  {rc*C[2]}\n')
    for i in range(Na):
        l = f.readline().split();
        e = l[0]
        r = np.asarray(l[1:4],dtype=np.float64)
        for a in range(ra):
            for b in range(rb):
                for c in range(rc):
                    fo.write(f'{e} {r[0]+a*A[0]+b*B[0]+c*C[0]}  {r[1]+a*A[1]+b*B[1]+c*C[1]}  {r[2]+a*A[2]+b*B[2]+c*C[2]} \n')
    f.close()
    fo.close()


#**********************************************************************************
def axyz2pairdist(fin_axyz):
    Nc = int(os.popen('cat '+fin_axyz+' | grep snap | wc -l').read().strip()); #Total number of snapshots
    S=io.read(fin_axyz,format='xyz',index=0)
    els=S.get_chemical_symbols()
    el=[]
    freq=[]
    for i in els:
        if i not in el:
            el.append(i)
            freq.append(1)
        else:
            freq[el.index(i)] += 1;

    print(el,freq)
    
    Na=len(els)
    pairs=[]
    for i in range(len(el)):
        for j in range(i,len(el)):
            pairs.append([el[i],el[j]])
    Npairs = len(pairs)
    for i1 in range(Npairs):
        print(pairs[i1][0], freq[el.index(pairs[i1][0])])
    
    print('Elements: ',el,'; Pairs: ',pairs)
    pair_index = [[] for _ in range(Npairs)]
    dist1      = [[] for _ in range(Npairs)]

    dr   = 0.05
    Nbin = int(np.ceil(25/dr))
    gr   = np.zeros([Npairs,Nbin],dtype=float) 
    R    = [dr*(i) for i in range(Nbin)]
    
    for i in range(Na-1):
        for j in range(i+1,Na):
            for pp in pairs:
                if( (els[i]==pp[0] and els[j]==pp[1]) or (els[i]==pp[1] and els[j]==pp[0])):
                    pair_index[pairs.index(pp)].append([i,j])
    #print(pair_index[0])
    print(el,pairs,[len(i) for i in pair_index],len(pair_index))
    
    fs=open(fin_axyz)
    for s in range(Nc): #Nc
        print(s)
        Na=int(fs.readline().split()[0]);
        l2=fs.readline().split();
        sno=l2[0];
        Esnap=float(l2[1]);
        A=[float(k) for k in l2[2:5]];B=[float(k) for k in l2[5:8]];C=[float(k) for k in l2[8:11]];
        elements=[];
        coord=np.zeros([Na,3],dtype=float);#>>Atomic coordinates
        for i in range(Na):
            l=fs.readline().split();
            elements.append(l[0]);
            coord[i]=l[1:4];
        S.set_cell([A,B,C])
        S.set_pbc(True)
        S.set_positions(coord,apply_constraint=False)
        #ana=Analysis(S)
        #ub=ana.unique_bonds
        gr_tmp   = np.zeros([Npairs,Nbin],dtype=float)

        for i1 in range(Npairs):
            for j in pair_index[i1]:
                d=S.get_distance(j[0],j[1],mic=True)

                gr_tmp[i1][round(d/dr)] += 1;
                dist1[i1].append(d)
                #if(d < 15):
                #    dist1[i1].append(d)

        for i1 in range(Npairs):
            rho = freq[el.index(pairs[i1][1])]/S.get_volume();
            for j1 in range(1,Nbin):
                gr_tmp[i1][j1] = gr_tmp[i1][j1]/(4*math.pi*R[j1]*R[j1]*dr)
            gr[i1] = gr[i1] + gr_tmp[i1]/rho/freq[el.index(pairs[i1][0])]
    fs.close()

    gr = gr/Nc;
    
    #hist, bin_edges = np.histogram(dist[0], bins = range(5))
    cc = ['r','g','b','teal','purple','peru','gray','lime','orchid','gold','orange']
    fig = plt.figure(figsize=(25, 12))
    for i in range(len(pairs)):
        #plt.hist(dist1[i],density='True',bins=200,color=cc[i],label=pairs[i][0]+pairs[i][1])
        plt.plot(R,gr[i],color=cc[i],label=pairs[i][0]+pairs[i][1])
    plt.legend()
    fig.savefig('gr.png',dpi=300,bbox_inches="tight")
    plt.close()

    fig = plt.figure(figsize=(25, 12))
    for i in range(len(pairs)):
        fig = plt.figure(figsize=(25, 12))
        plt.plot(R,gr[i],color=cc[i],label=pairs[i][0]+pairs[i][1])
        plt.legend()
        plt.xlim([0, 8])
        plt.plot([0,8],[1,1],'-')
        fig.savefig('gr_'+str(i)+'.png',dpi=300,bbox_inches="tight")
        plt.close()

    fig = plt.figure(figsize=(25, 12))
    for i in range(len(pairs)):
        plt.hist(dist1[i],density='True',bins=200,color=cc[i],label=pairs[i][0]+pairs[i][1])
    plt.legend()
    fig.savefig('dist.png',dpi=300,bbox_inches="tight")
    plt.close()


#*****************************************
#************Charge Analysis

def axyz2_qdist(fin_axyz,keyword):
    #This function convert file in axyz format to jl compatible extended xyz
    #fname: name of input xyz file
    #fout: name of output file
    #keyword: this string will be use to find number of snapshots in the file
    
      
    Nconfig = int(os.popen('cat '+fin_axyz+' | grep '+ keyword + ' | wc -l').read())
    print('Going to analyze charges frome ',Nconfig,' configurations')
    
    fi = open(fin_axyz,'r') 
    atm_tp=[];
    for i in range(1): # Just reading first configurations to find atom types
        Na = int(fi.readline().split()[0])
        fi.readline()
        for j in range(Na):
            l = fi.readline().split()
            if l[0] not in atm_tp:
                atm_tp.append(l[0])
    fi.close();
    print(atm_tp)
         
    q = [[] for _ in range(len(atm_tp))]
    
    fi = open(fin_axyz,'r') 
    for i in range(Nconfig): 
        Na = int(fi.readline().split()[0])
        fi.readline()
        for j in range(Na):
            l = fi.readline().split()
            q[atm_tp.index(l[0])].append(float(l[7]))        
    fi.close();
    
    fig = plt.figure(figsize=(25, 12))
    for i in range(len(atm_tp)):
        plt.hist(q[i],label=atm_tp[i],bins=100,alpha=0.5)        
    plt.legend()
    fig.savefig('charge_hist.png',dpi=300,bbox_inches="tight")
    plt.close()
        
    
#
